"""
module for the calculation of shiedling and coupling constants 
"""

import os
import shutil
import sys
from random import normalvariate
from multiprocessing import JoinableQueue as Queue
from .cfg import PLENGTH, DIGILEN, AU2KCAL
from .parallel import run_in_parallel
from .orca_job import OrcaJob
from .tm_job import TmJob
from .utilities import (
    calc_boltzmannweights,
    printout,
    print_block,
    new_folders,
    last_folders,
    print,
    write_anmrrc,
    calc_std_dev,
)


def read_chemeq(path):
    """read chemeq from anmr_nucinfo"""
    with open(path, "r") as inp:
        data = inp.readlines()
    nat = int(data[0].split()[0])
    tmpeq = {}
    for i in range(1, nat * 2 + 1):
        if i % 2 != 0:
            nextatom = int(data[i].split()[0])
        elif i % 2 == 0:
            equalatoms = [int(x) for x in data[i].split()]
            tmpeq[nextatom] = sorted(equalatoms)
    return tmpeq


def read_exp_ref(path):
    """read experimental reference shifts"""
    with open(os.path.join(path, ".ref"), "r") as inp:
        data = inp.readlines()
    expref = {}
    for line in data[1:]:
        if line not in ["\n", "\r\n"]:
            try:
                expref[int(line.split()[0])] = float(line.split()[1])
            except ValueError:
                pass
    return expref


def get_atom(path):
    """read coord"""
    with open(os.path.join(path, "coord"), "r") as inp:
        data = inp.readlines()
    element = {}
    i = 1
    for line in data[1:]:
        if "$" in line:  # stop at $end ...
            break
        element[i] = str(line.split()[3].lower())
        i += 1
    return element


def average_shieldings(config, calculate, element_ref_shield, energy, solv, rrho):
    """
    Read chemical equivalence and Boltzmann average the calculated shielding constants
    """
    path_anmr_nucinfo = os.path.join(config.cwd, "anmr_nucinfo")
    if not os.path.isfile(path_anmr_nucinfo):
        print(f"File anmr_nucinfo (generated by CREST) is not present!")
        return
    chemeq = read_chemeq(path_anmr_nucinfo)
    averaged = {}
    element = {}

    sigma_std_dev = {}
    for i in range(1, config.nat + 1):
        sigma_std_dev[i] = []

    for conf in calculate:
        # get shielding constants
        if not element:
            element = get_atom(
                os.path.normpath(os.path.join(config.cwd, "CONF" + str(conf.id), "NMR"))
            )
        for atom in conf.shieldings.keys():
            sigma = sum(
                [conf.shieldings.get(eq_atom, 0.0) for eq_atom in chemeq[atom]]
            ) / len(chemeq[atom])
            averaged[atom] = conf.bm_weight * sigma + averaged.get(atom, 0.0)

    for _ in range(1000):
        for conf in calculate:
            conf.calc_free_energy(e=energy, solv=solv, rrho=rrho)
            conf.free_energy += normalvariate(
                0.0, conf.lowlevel_gsolv_compare_info["std_dev"]
            )
        calculate = calc_boltzmannweights(calculate, "free_energy", config.temperature)
        for conf in calculate:
            # get shielding constants
            if not element:
                element = get_atom(
                    os.path.normpath(
                        os.path.join(config.cwd, "CONF" + str(conf.id), "NMR")
                    )
                )
            for atom in conf.shieldings.keys():
                sigma = sum(
                    [conf.shieldings.get(eq_atom, 0.0) for eq_atom in chemeq[atom]]
                ) / len(chemeq[atom])
                sigma_std_dev[atom].append(
                    conf.bm_weight * sigma + averaged.get(atom, 0.0)
                )

    print("\nAveraged shielding constants:")
    print("# in coord  element  σ(sigma)  SD(σ based on SD Gsolv)   shift")
    print("".ljust(int(70), "-"))
    maxsigma = max([len(str(sigma).split(".")[0]) for sigma in averaged.values()]) + 5
    make_shift = (
        lambda atom: f"{-sigma+element_ref_shield.get(element[atom], 0.0):> {maxsigma}.2f}"
        if (element_ref_shield.get(element[atom], None) is not None)
        else "None"
    )
    for atom, sigma in averaged.items():
        try:
            std_dev = calc_std_dev(sigma_std_dev[atom])
        except Exception as e:
            print(e)
            std_dev = 0.0
        try:
            print(
                f"{atom:< {10}}  {element[atom]:^{7}}  {sigma:> {maxsigma}.2f}  "
                f"{std_dev:^ 24.6f} {make_shift(atom):>5}"
            )
        except:
            print(f"{atom:< {10}}  {element[atom]:^{7}}  {sigma:> {maxsigma}.2f}")
    print("".ljust(int(70), "-"))


def part4(config, conformers, store_confs, ensembledata):
    """
    Calculate nmr properties: shielding and coupling constants on the populated
    conformers (either directly from part2 OPTIMIZATION or after REFINEMENT
    (part3))
    """
    save_errors = []
    print("\n" + "".ljust(PLENGTH, "-"))
    print("NMR MODE - PART4".center(PLENGTH, " "))
    print("".ljust(PLENGTH, "-") + "\n")
    # print flags for part3
    info = []
    info.append(["couplings", "calculate coupling constants"])
    if config.couplings:
        info.append(["prog4_j", "prog4J - program for coupling constant calculation"])
        info.append(["func_j", "funcJ  - functional for coupling constant calculation"])
        info.append(["basis_j", "basisJ - basis for coupling constant calculation"])
        if config.solvent != "gas":
            info.append(["sm4_j", "sm4J - solvent model for the coupling calculation"])
    info.append(["shieldings", "calculate shielding constants σ"])
    if config.shieldings:
        info.append(["prog4_s", "prog4S - program for shielding constant calculation"])
        info.append(["func_s", "funcS - functional for shielding constant calculation"])
        info.append(["basis_s", "basisS - basis for shielding constant calculation"])
        if config.solvent != "gas":
            info.append(["sm4_s", "sm4S - solvent model for the shielding calculation"])
    info.append(["resonance_frequency", "spectrometer frequency"])
    # active nuclei

    optionsexchange = {True: "on", False: "off"}
    for item in info:
        if item[0] == "justprint":
            print(item[1:][0])
        else:
            if item[0] == "printoption":
                option = item[2]
            else:
                option = getattr(config, item[0])
            if option is True or option is False:
                option = optionsexchange[option]
            elif isinstance(option, list):
                option = [str(i) for i in option]
                if len(str(option)) > 40:
                    length = 0
                    reduced = []
                    for i in option:
                        length += len(i) + 2
                        if length < 40:
                            reduced.append(i)
                    reduced.append("...")
                    option = reduced
                    length = 0
                option = ", ".join(option)
            print(
                "{}: {:{digits}} {}".format(
                    item[1], "", option, digits=DIGILEN - len(item[1])
                )
            )
    print("")
    # end print

    calculate = []  # has to be calculated in this run
    prev_calculated = []  # was already calculated in a previous run
    try:
        store_confs
    except NameError:
        store_confs = []  # stores all confs which are sorted out!

    # setup queues
    q = Queue()
    resultq = Queue()

    # sort conformers:
    for conf in list(conformers):
        if conf.removed:
            store_confs.append(conformers.pop(conformers.index(conf)))
            print(f"CONF{conf.id} is removed as requested by the user!")
            continue
        if (
            conf.part_info["part2"] == "passed"
            and conf.optimization_info["info"] == "calculated"
        ):
            if not config.part3:
                # part3 is not calculated use boltzmann weights directly from part2
                energy = "lowlevel_sp_info"
                rrho = "lowlevel_grrho_info"
                gsolv = "lowlevel_gsolv_info"
                boltzmannthr = config.part2_threshold
            elif config.part3:
                # calc boltzmann weights from part3
                energy = "highlevel_sp_info"
                rrho = "highlevel_grrho_info"
                gsolv = "highlevel_gsolv_info"
                boltzmannthr = config.part3_threshold
            else:
                print("UNEXPECTED BEHAVIOUR")
            mol = conformers.pop(conformers.index(conf))
            if getattr(conf, energy)["info"] != "calculated":
                store_confs.append(mol)
                continue
            elif getattr(conf, rrho)["info"] != "calculated" and config.evaluate_rrho:
                store_confs.append(mol)
                continue
            elif (
                getattr(conf, gsolv)["info"] != "calculated" and config.solvent != "gas"
            ):
                store_confs.append(mol)
                continue
            else:
                calculate.append(mol)
        else:
            print(
                f"WARNING: CONF{conf.id} has not been optimized (part2)! "
                f"Removing CONF{conf.id}"
            )
            conf = conformers.pop(conformers.index(conf))
            store_confs.append(conf)

    if not calculate and not prev_calculated:
        print("ERROR: No conformers left!")
        print("Going to exit!")
        sys.exit(1)

    calculate.sort(key=lambda x: int(x.id))
    print("Considering the following conformers:")
    print_block(["CONF" + str(i.id) for i in calculate])

    # Calculate boltzmann weight for confs:
    if not config.part3:
        if not config.evaluate_rrho:
            rrho = None
        else:
            rrho_method, _ = config.get_method_name(
                "rrhoxtb",
                bhess=config.bhess,
                gfn_version=config.part2_gfnv,
                sm=config.sm_rrho,
                solvent=config.solvent,
            )
        if config.solvent == "gas":
            gsolv = None
            energy_method, _ = config.get_method_name(
                "xtbopt",
                func=config.func,
                basis=config.basis,
                sm=config.smgsolv2,
                gfn_version=config.part2_gfnv,
                solvent=config.solvent,
            )
        else:
            if config.smgsolv2 in ("cosmors", "cosmors-fine"):
                tmp_name = "cosmors"
            elif config.smgsolv2 in ("alpb_gsolv", "gbsa_gsolv", "smd_gsolv"):
                tmp_name = config.smgsolv2
            else:
                tmp_name = "sp_implicit"
            energy_method, solv_method = config.get_method_name(
                tmp_name,
                func=config.func,
                basis=config.basis,
                sm=config.smgsolv2,
                gfn_version=config.part2_gfnv,
                solvent=config.solvent,
            )
    elif config.part3:
        if not config.evaluate_rrho:
            rrho = None
        else:
            rrho_method, _ = config.get_method_name(
                "rrhoxtb",
                bhess=config.bhess,
                gfn_version=config.part3_gfnv,
                sm=config.sm_rrho,
                solvent=config.solvent,
            )
        if config.solvent == "gas":
            gsolv = None
            energy_method, _ = config.get_method_name(
                "xtbopt",
                func=config.func3,
                basis=config.basis3,
                sm=config.smgsolv3,
                gfn_version=config.part3_gfnv,
                solvent=config.solvent,
            )
        else:
            if config.smgsolv3 in ("cosmors", "cosmors-fine"):
                tmp_name = "cosmors"
            elif config.smgsolv3 in ("alpb_gsolv", "gbsa_gsolv", "smd_gsolv"):
                tmp_name = config.smgsolv3
            else:
                tmp_name = "sp_implicit"
            energy_method, solv_method = config.get_method_name(
                tmp_name,
                func=config.func3,
                basis=config.basis3,
                sm=config.smgsolv3,
                gfn_version=config.part3_gfnv,
                solvent=config.solvent,
            )

    for conf in calculate:
        conf.calc_free_energy(e=energy, solv=gsolv, rrho=rrho)
    calculate = calc_boltzmannweights(calculate, "free_energy", config.temperature)
    try:
        minfree = min([i.free_energy for i in calculate if i is not None])
    except ValueError:
        raise
    for conf in calculate:
        conf.rel_free_energy = (conf.free_energy - minfree) * AU2KCAL
    calculate.sort(key=lambda x: int(x.id))

    # printout for part4 -------------------------------------------------------
    print("\n" + "".ljust(int(PLENGTH / 2), "-"))
    print("* Gibbs free energies used in part4 *".center(int(PLENGTH / 2), " "))
    print("".ljust(int(PLENGTH / 2), "-") + "\n")
    columncall = [
        lambda conf: "CONF" + str(getattr(conf, "id")),
        lambda conf: getattr(conf, energy)["energy"],
        lambda conf: getattr(conf, gsolv)["energy"],
        lambda conf: getattr(conf, rrho)["energy"],
        lambda conf: getattr(conf, "free_energy"),
        lambda conf: getattr(conf, "rel_free_energy"),
        lambda conf: getattr(conf, "bm_weight") * 100,
    ]
    columnheader = [
        "CONF#",
        "E [Eh]",
        "Gsolv [Eh]",
        "GmRRHO [Eh]",
        "Gtot",
        "ΔGtot",
        "Boltzmannweight",
    ]
    columndescription = [
        "",
        "",
        "",
        "",
        "[Eh]",
        "[kcal/mol]",
        f"  % at {config.temperature:.2f} K",
    ]
    columnformat = ["", (12, 7), (12, 7), (12, 7), (12, 7), (5, 2), (5, 2)]
    columndescription[1] = energy_method
    columndescription[2] = solv_method
    columndescription[3] = rrho_method
    if not config.evaluate_rrho or config.solvent == "gas":
        if not config.evaluate_rrho:
            # ignore rrho in printout
            columncall.pop(3)
            columnheader.pop(3)
            columndescription.pop(3)
            columnformat.pop(3)
        if config.solvent == "gas":
            columncall.pop(2)
            columnheader.pop(2)
            columndescription.pop(2)
            columnformat.pop(2)

    printout(
        os.path.join(config.cwd, "part4.dat"),
        columncall,
        columnheader,
        columndescription,
        columnformat,
        calculate,
        minfree,
    )
    calculate.sort(reverse=True, key=lambda x: float(x.bm_weight))
    sumup = 0.0
    for conf in list(calculate):
        sumup += conf.bm_weight
        if sumup >= boltzmannthr:
            if conf.bm_weight < (1 - boltzmannthr):
                store_confs.append(calculate.pop(calculate.index(conf)))
    print(f"\nConformers that are below the Boltzmann-thr of {boltzmannthr}:")
    print_block(["CONF" + str(i.id) for i in calculate])

    # create NMR folder
    folder = "NMR"
    save_errors, store_confs, calculate = new_folders(
        config.cwd, calculate, folder, save_errors, store_confs
    )
    # need to copy optimized coord to folder
    for conf in list(calculate):
        tmp1 = os.path.join(config.cwd, "CONF" + str(conf.id), config.func, "coord")
        tmp2 = os.path.join("CONF" + str(conf.id), folder, "coord")
        try:
            shutil.copy(tmp1, tmp2)
        except FileNotFoundError:
            print("ERROR can't copy optimized geometry!")
            store_confs.append(calculate.pop(calculate.index(conf)))
    if config.couplings:
        print("\nPerforming coupling constant calculations:")
        # check if J calculated before!
        for conf in list(calculate):
            if getattr(conf, "nmr_coupling_info")["info"] == "calculated":
                prev_calculated.append(calculate.pop(calculate.index(conf)))
            elif getattr(conf, "nmr_coupling_info")["info"] == "failed":
                store_confs.append(calculate.pop(calculate.index(conf)))
            else:
                # still in calculate
                pass

        if not calculate + prev_calculated:
            print("ERROR: No conformers left!")
            print("Going to exit!")
            sys.exit(1)

        instruction_j = {
            "jobtype": "couplings_sp",
            "prepinfo": ["high+"],
            "func": config.func_j,
            "basis": config.basis_j,
            "charge": config.charge,
            "unpaired": config.unpaired,
            "solvent": config.solvent,
            "sm": config.sm4_j,
            "success": False,
            "omp": config.omp,
            # nmractive nuclei
            "h_active": config.h_active,
            "c_active": config.c_active,
            "f_active": config.f_active,
            "p_active": config.p_active,
            "si_active": config.si_active,
        }
        if config.prog4_j == "orca":
            job = OrcaJob
            instruction_j["progpath"] = config.external_paths["orcapath"]
            instruction_j["method"], _ = config.get_method_name(
                instruction_j["jobtype"],
                func=instruction_j["func"],
                basis=instruction_j["basis"],
                sm=instruction_j["sm"],
                solvent=instruction_j["solvent"],
                prog=config.prog4_j,
            )
        elif config.prog4_j == "tm":
            job = TmJob
            instruction_j["progpath"] = config.external_paths["escfpath"]
            instruction_j["method"], _ = config.get_method_name(
                instruction_j["jobtype"],
                func=instruction_j["func"],
                basis=instruction_j["basis"],
                sm=instruction_j["sm"],
                solvent=instruction_j["solvent"],
                prog=config.prog4_j,
            )
            # escf no mgrid!!!!
        elif config.prog4_j == "adf":
            instruction_j["method"], _ = config.get_method_name(
                instruction_j["jobtype"],
                func=instruction_j["func"],
                basis=instruction_j["basis"],
                sm=instruction_j["sm"],
                solvent=instruction_j["solvent"],
                prog=config.prog4_j,
            )
        check = {True: "was successful", False: "FAILED"}
        pl = config.lenconfx + 4 + len(str("/" + folder))
        if calculate:
            calculate = run_in_parallel(
                config,
                q,
                resultq,
                job,
                config.maxthreads,
                calculate,
                instruction_j,
                folder,
            )
            for conf in list(calculate):
                line = (
                    f"Coupling constant calculation {check[conf.job['success']]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}: "
                )
                print(line)
                if not conf.job["success"]:
                    save_errors.append(line)
                    conf.nmr_coupling_info["info"] = "failed"
                    conf.nmr_coupling_info["method"] = instruction_j["method"]
                    conf.nmr_coupling_info["h_active"] = instruction_j["h_active"]
                    conf.nmr_coupling_info["c_active"] = instruction_j["c_active"]
                    conf.nmr_coupling_info["f_active"] = instruction_j["f_active"]
                    conf.nmr_coupling_info["si_active"] = instruction_j["si_active"]
                    conf.nmr_coupling_info["p_active"] = instruction_j["p_active"]
                    conf.part_info["part4"] = "refused"
                    store_confs.append(calculate.pop(calculate.index(conf)))
                else:
                    conf.nmr_coupling_info["info"] = "calculated"
                    conf.nmr_coupling_info["method"] = instruction_j["method"]
                    conf.nmr_coupling_info["h_active"] = instruction_j["h_active"]
                    conf.nmr_coupling_info["c_active"] = instruction_j["c_active"]
                    conf.nmr_coupling_info["f_active"] = instruction_j["f_active"]
                    conf.nmr_coupling_info["si_active"] = instruction_j["si_active"]
                    conf.nmr_coupling_info["p_active"] = instruction_j["p_active"]
            # save current data to jsonfile
            config.write_json(
                config.cwd,
                [i.provide_runinfo() for i in calculate]
                + [i.provide_runinfo() for i in prev_calculated]
                + [i.provide_runinfo() for i in store_confs]
                + [ensembledata],
                config.provide_runinfo(),
            )

        if prev_calculated:
            for conf in list(prev_calculated):
                conf.job["workdir"] = os.path.normpath(
                    os.path.join(config.cwd, "CONF" + str(conf.id), folder)
                )
                line = (
                    f"Coupling constant calculation {check[True]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}: "
                )
                print(line)
                calculate.append(prev_calculated.pop(prev_calculated.index(conf)))

        for conf in calculate:
            conf.reset_job_info()
        if not calculate:
            print("ERROR: No conformers left!")
            print("Going to exit!")
            sys.exit(1)

    if config.shieldings:
        print("\nPerforming shielding constant calculations:")
        # start shielding constants
        # check if S calculated before!
        for conf in list(calculate):
            if getattr(conf, "nmr_shielding_info")["info"] == "calculated":
                prev_calculated.append(calculate.pop(calculate.index(conf)))
            elif getattr(conf, "nmr_shielding_info")["info"] == "failed":
                store_confs.append(calculate.pop(calculate.index(conf)))
        for conf in calculate:
            conf.reset_job_info()
        if not calculate + prev_calculated:
            print("ERROR: No conformers left!")
            print("Going to exit!")
            sys.exit(1)

        instruction_s = {
            "jobtype": "shieldings_sp",
            "prepinfo": ["high+"],
            "func": config.func_s,
            "basis": config.basis_s,
            "charge": config.charge,
            "unpaired": config.unpaired,
            "solvent": config.solvent,
            "sm": config.sm4_s,
            "success": False,
            "omp": config.omp,
            # nmractive nuclei
            "h_active": config.h_active,
            "c_active": config.c_active,
            "f_active": config.f_active,
            "p_active": config.p_active,
            "si_active": config.si_active,
        }

        if config.basis_j != config.basis_s:
            # do a new calculation
            # cefine if turbomole
            instruction_s["prepinfo"] = ["high+"]
        if config.prog4_j != config.prog4_s:
            # do a new calculation
            # cefine if turbomole
            instruction_s["prepinfo"] = ["high+"]
        if (config.basis_j == config.basis_s) and (config.prog4_j == config.prog4_s):
            if config.func_j == config.func_s and config.couplings:
                instruction_s["prepinfo"] = []
                # don't do single-point
                instruction_s["jobtype"] = "shieldings"
            elif config.func_j != config.func_s and config.couplings:
                instruction_s["prepinfo"] = ["high+"]
                # use already converged mos as start mos
                if config.prog4_s == "tm":
                    instruction_s["copymos"] = "mos_j"
                instruction_s["jobtype"] = "shieldings_sp"

        if config.prog4_s == "orca":
            job = OrcaJob
            instruction_s["progpath"] = config.external_paths["orcapath"]
            instruction_s["method"], _ = config.get_method_name(
                instruction_s["jobtype"],
                func=instruction_s["func"],
                basis=instruction_s["basis"],
                sm=instruction_s["sm"],
                solvent=instruction_s["solvent"],
                prog=config.prog4_s,
            )
        elif config.prog4_s == "tm":
            job = TmJob
            instruction_s["progpath"] = config.external_paths["mpshiftpath"]
            instruction_s["method"], _ = config.get_method_name(
                instruction_s["jobtype"],
                func=instruction_s["func"],
                basis=instruction_s["basis"],
                sm=instruction_s["sm"],
                solvent=instruction_s["solvent"],
                prog=config.prog4_j,
            )
        elif config.prog4_s == "adf":
            instruction_s["method"], _ = config.get_method_name(
                instruction_s["jobtype"],
                func=instruction_s["func"],
                basis=instruction_s["basis"],
                sm=instruction_s["sm"],
                solvent=instruction_s["solvent"],
                prog=config.prog4_j,
            )
        check = {True: "was successful", False: "FAILED"}
        pl = config.lenconfx + 4 + len(str("/" + folder))
        if calculate:
            calculate = run_in_parallel(
                config,
                q,
                resultq,
                job,
                config.maxthreads,
                calculate,
                instruction_s,
                folder,
            )
            for conf in list(calculate):
                line = (
                    f"Shielding constant calculation {check[conf.job['success']]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}: "
                )
                print(line)
                if not conf.job["success"]:
                    save_errors.append(line)
                    conf.nmr_shielding_info["info"] = "failed"
                    conf.nmr_shielding_info["method"] = instruction_s["method"]
                    conf.nmr_shielding_info["h_active"] = instruction_s["h_active"]
                    conf.nmr_shielding_info["c_active"] = instruction_s["c_active"]
                    conf.nmr_shielding_info["f_active"] = instruction_s["f_active"]
                    conf.nmr_shielding_info["si_active"] = instruction_s["si_active"]
                    conf.nmr_shielding_info["p_active"] = instruction_s["p_active"]
                    conf.part_info["part4"] = "refused"
                    store_confs.append(calculate.pop(calculate.index(conf)))
                else:
                    conf.nmr_shielding_info["info"] = "calculated"
                    conf.nmr_shielding_info["method"] = instruction_s["method"]
                    conf.nmr_shielding_info["h_active"] = instruction_s["h_active"]
                    conf.nmr_shielding_info["c_active"] = instruction_s["c_active"]
                    conf.nmr_shielding_info["f_active"] = instruction_s["f_active"]
                    conf.nmr_shielding_info["si_active"] = instruction_s["si_active"]
                    conf.nmr_shielding_info["p_active"] = instruction_s["p_active"]
            # save current data to jsonfile
            config.write_json(
                config.cwd,
                [i.provide_runinfo() for i in calculate]
                + [i.provide_runinfo() for i in prev_calculated]
                + [i.provide_runinfo() for i in store_confs]
                + [ensembledata],
                config.provide_runinfo(),
            )
        if prev_calculated:
            for conf in list(prev_calculated):
                conf.job["workdir"] = os.path.normpath(
                    os.path.join(config.cwd, "CONF" + str(conf.id), folder)
                )
                line = (
                    f"Shielding constant calculation {check[True]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}: "
                )
                print(line)
                calculate.append(prev_calculated.pop(prev_calculated.index(conf)))

    # write anmr_enso output!
    print("\nGenerating file anmr_enso for processing with the ANMR program.")
    for conf in calculate:
        conf.calc_free_energy(e=energy, solv=gsolv, rrho=rrho)
    calculate = calc_boltzmannweights(calculate, "free_energy", config.temperature)
    try:
        length = max([str(i.id) for i in calculate])
        if length < 4:
            length = 4
        fmtenergy = max([len("{:.7f}".format(i.free_energy)) for i in calculate])
    except:
        length = 6
        fmtenergy = 10
    with open(os.path.join(config.cwd, "anmr_enso"), "w", newline=None) as out:
        out.write(
            f"{'ONOFF':5} {'NMR':^{length}} {'CONF':^{length}} {'BW':6} "
            f"{'Energy':{fmtenergy}} {'Gsolv':7}  {'mRRHO':7} {'gi':7}\n"
        )
        for conf in calculate:
            out.write(
                f"{1:<5} {conf.id:{length}} {conf.id:{length}} "
                f"{conf.bm_weight:.4f} {getattr(conf, energy)['energy']:.5f} "
                f"{getattr(conf, gsolv)['energy']:.5f} "
                f"{getattr(conf, rrho)['energy']:.5f} "
                f"{conf.gi:.3f}\n"
            )

    # write .anmrrc
    print("\nWriting .anmrrc!")
    element_ref_shield = write_anmrrc(config)

    print("\nGenerating plain nmrprop.dat files for each populated conformer.")
    print("These files contain all calculated shielding and coupling constants.")
    print("The files can be read by ANMR using the keyword '-plain'.\n")
    # write generic:
    instructgeneric = {"jobtype": "genericout", "nat": int(config.nat)}
    calculate = run_in_parallel(
        config, q, resultq, job, config.maxthreads, calculate, instructgeneric, folder
    )

    # printout the averaged shielding constants
    average_shieldings(config, calculate, element_ref_shield, energy, gsolv, rrho)

    for conf in calculate:
        conf.reset_job_info()

    # end printout for part4
    print("\n\n")
    return config, calculate, store_confs, ensembledata
